/**
 * Message counter for existing Obsidian notes
 *
 * Counts and extracts messages from note body across all 3 formats
 * generated by formatMessage() in markdown.ts.
 */

import { PLATFORM_LABELS } from './constants';

/** Build label alternation from PLATFORM_LABELS: "User|Gemini|Claude|..." */
const LABEL_ALTERNATION = ['User', ...Object.values(PLATFORM_LABELS), 'Assistant'].join('|');

/**
 * Pattern matching callout format: > [!TYPE] Label
 * Labels: User, Gemini, Claude, ChatGPT, Perplexity, Assistant
 */
const CALLOUT_PATTERN = new RegExp(`^> \\[!\\w+\\] (?:${LABEL_ALTERNATION})\\b`, 'gm');

/**
 * Pattern matching blockquote/plain format: **Label:**
 * Labels: User, Gemini, Claude, ChatGPT, Perplexity, Assistant
 */
const LABEL_PATTERN = new RegExp(`^\\*\\*(?:${LABEL_ALTERNATION}):\\*\\*`, 'gm');

/**
 * Pattern to match fenced code blocks (for exclusion)
 */
const CODE_BLOCK_PATTERN = /^```[^\n]*\n[\s\S]*?^```/gm;

/**
 * Combined pattern matching either callout or label format (for line scanning)
 */
const MESSAGE_START_PATTERN = new RegExp(
  `^(?:> \\[!\\w+\\] (?:${LABEL_ALTERNATION})\\b|\\*\\*(?:${LABEL_ALTERNATION}):\\*\\*)`
);

/**
 * Remove fenced code blocks from text to prevent false positives.
 * Replaces code block content with empty lines to preserve line structure.
 */
function stripCodeBlocks(text: string): string {
  return text.replace(CODE_BLOCK_PATTERN, match => {
    // Replace each line with empty string to preserve line count
    return match
      .split('\n')
      .map(() => '')
      .join('\n');
  });
}

/**
 * Count conversation messages in a note body.
 * Supports all 3 message formats generated by formatMessage().
 */
export function countExistingMessages(body: string): number {
  const stripped = stripCodeBlocks(body);

  // Try callout format first
  CALLOUT_PATTERN.lastIndex = 0;
  const calloutMatches = stripped.match(CALLOUT_PATTERN);
  if (calloutMatches && calloutMatches.length > 0) {
    return calloutMatches.length;
  }

  // Try blockquote/plain format
  LABEL_PATTERN.lastIndex = 0;
  const labelMatches = stripped.match(LABEL_PATTERN);
  if (labelMatches && labelMatches.length > 0) {
    return labelMatches.length;
  }

  return 0;
}

/**
 * Extract messages after skipCount from a formatted note body.
 * Returns formatted markdown for only the tail (new) messages.
 */
export function extractTailMessages(fullBody: string, skipCount: number): string {
  if (skipCount <= 0) return fullBody;

  const lines = fullBody.split('\n');
  let messageIndex = 0;
  let inCodeBlock = false;
  let tailStartLine = -1;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Track code block state
    if (line.startsWith('```')) {
      inCodeBlock = !inCodeBlock;
      continue;
    }

    // Skip lines inside code blocks
    if (inCodeBlock) continue;

    // Check if this line starts a new message
    if (MESSAGE_START_PATTERN.test(line)) {
      if (messageIndex === skipCount) {
        tailStartLine = i;
        break;
      }
      messageIndex++;
    }
  }

  if (tailStartLine === -1) return '';

  // Find the start of the tail, skipping leading empty lines separator
  let start = tailStartLine;
  // Look backwards to include the separator blank lines before the message
  // but only the separator, not content from previous messages
  while (start > 0 && lines[start - 1].trim() === '') {
    start--;
  }
  // We want the new messages to start cleanly, so use tailStartLine
  return lines.slice(tailStartLine).join('\n');
}
